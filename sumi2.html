<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Suminagashi</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        canvas {
            display: block;
            background-color: white;
        }
    </style>
</head>
<body>
    <canvas id="artCanvas"></canvas>
    
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@teachablemachine/image@latest/dist/teachablemachine-image.min.js"></script>
    
    <script>
        const URL = "https://teachablemachine.withgoogle.com/models/DEf-K_173/"; // Your model directory
        let model, webcam, maxPredictions;
        let canvas, ctx, blobs = [], growing = false, currentColor = "black";
        let canvasWidth = window.innerWidth;
        let canvasHeight = window.innerHeight;

        // Blob class to handle growth and ripple effect
        class Blob {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.radius = 10; // Start with a small radius
        this.distortionFactor = 0; // Start as a perfect circle
        this.noiseOffset = Math.random() * 1000; // Offset for smoother random distortion
    }

    // Draw the blob with slow, gentle ripple distortions
    draw() {
        ctx.beginPath();
        for (let i = 0; i < 100; i++) {
            let angle = (i / 100) * Math.PI * 2;
            // Smoother ripple effect using sine waves with a gentle variation
            let smoothDistortion = Math.sin(angle + this.noiseOffset) * this.distortionFactor * 0.5;
            let dist = this.radius + smoothDistortion;
            let blobX = this.x + Math.cos(angle) * dist;
            let blobY = this.y + Math.sin(angle) * dist;
            ctx.lineTo(blobX, blobY);
        }
        ctx.closePath();
        ctx.fillStyle = this.color;
        ctx.fill();
    }

    // Slowly grow the blob and gently increase ripple distortion
    grow() {
        this.radius += 0.6; // Slower outward growth
        if (this.distortionFactor < 10) { // Limit distortion to keep it subtle
            this.distortionFactor += 0.01; // Slow, fluid increase in ripple strength
        }
        this.noiseOffset += 0.02; // Slowly move the distortion pattern for gentle ripples
    }
}







        // Initialize the canvas and draw the first blob
        function initCanvas() {
            canvas = document.getElementById("artCanvas");
            ctx = canvas.getContext("2d");
            resizeCanvas();
            draw();
        }

        // Resize the canvas to match the window size
        function resizeCanvas() {
            canvasWidth = window.innerWidth;
            canvasHeight = window.innerHeight;
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
        }

        // Draw and animate the blobs
        function draw() {
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
            blobs.forEach(blob => {
                blob.draw();
                blob.grow();
            });
            requestAnimationFrame(draw);
        }

        // Create a new blob when a "Wave" is detected
        function createBlob(color) {
            blobs.push(new Blob(canvasWidth / 2, canvasHeight / 2, color));
        }

        // Initialize Teachable Machine
        async function init() {
            const modelURL = URL + "model.json";
            const metadataURL = URL + "metadata.json";

            model = await tmImage.load(modelURL, metadataURL);
            maxPredictions = model.getTotalClasses();

            webcam = new tmImage.Webcam(200, 200, true);
            await webcam.setup();
            await webcam.play();
            window.requestAnimationFrame(loop);

            initCanvas();
        }

        // Detect gestures and trigger blob generation
        async function loop() {
            webcam.update();
            await predict();
            window.requestAnimationFrame(loop);
        }

        async function predict() {
            const prediction = await model.predict(webcam.canvas);

            let highestPrediction = prediction.find(p => p.probability > 0.9);
            if (highestPrediction && highestPrediction.className === "Wave") {
                if (!growing) {
                    createBlob("black"); // Start new black blob
                    growing = true;
                }
            } else {
                if (growing) {
                    createBlob("white"); // Start new white blob
                    growing = false;
                }
            }
        }

        window.addEventListener('load', init);
        window.addEventListener('resize', resizeCanvas);
    </script>
</body>
</html>
